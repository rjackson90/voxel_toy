#include <GL/glew.h>
#include <iostream>
#include <signal.h>

#include "dispatch.h"

// Special header generated by build system, defines variables holding absolute 
// paths to module data directories
#include "data_paths.h"

using namespace std;

struct Subsystems;
class Dispatch;
class RenderSystem;
class PhysicsSystem;


int main()
{
    // Create container struct and initialize subsystems
    Subsystems systems;
    systems.render = std::unique_ptr<RenderSystem>(new RenderSystem(1024, 768, "Really Fun Game!"));
    systems.physics = std::unique_ptr<PhysicsSystem>(new PhysicsSystem());
    systems.dispatch = std::unique_ptr<Dispatch>(new Dispatch());

    // Register signal handler with the system
    cout << "Setting system signal handler." << endl;
    signal(SIGINT, Dispatch::signal_handler);

    // Generate geometry
    Rendering::Geometry cube;
    cube.genTestCube();
    cube.setDrawMode(GL_TRIANGLES);

    // Load program and textures
    Rendering::Program phong_program(Paths::shaders+"phong.vs", Paths::shaders+"phong.fs");
    Rendering::Texture stonebrick(GL_TEXTURE_2D, Paths::rendering+"stonebrick.tga");
    Rendering::Texture stonebrickn(GL_TEXTURE_2D, Paths::rendering+"stonebrickn.tga");

    // Set texture sampling parameters
    Rendering::SamplerParams params;
    params.min_filter = GL_LINEAR;
    
    Rendering::Sampler linear_blend(params);

    params.min_filter = GL_NEAREST;
    params.mag_filter = GL_NEAREST;

    Rendering::Sampler nearest_sample(params);

    // Create uniform blocks
    auto transform = std::make_shared<Rendering::TransformBlock>();
    auto point_light = std::make_shared<Rendering::PointLight>();
    auto material = std::make_shared<Rendering::Material>();

    // Set initial values for uniforms
    transform->mvp = glm::mat4(1.0f);
    transform->mv = glm::mat4(1.0f);
    transform->normal_matrix = glm::mat4(1.0f);

    point_light->position = glm::vec3(0.0f, 0.0f, 0.0f);
    point_light->intensity = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);

    material->ambient = glm::vec4(0.2f, 0.15f, 0.25f, 1.0f);
    material->diffuse = glm::vec4(0.6f, 0.65f, 0.6f, 1.0f);
    material->specular = glm::vec4(0.95f, 0.9f, 0.99f, 1.0f);
    material->shininess = 20.0f;

    // Create uniform buffers to back the blocks
    Rendering::UniformBuffer transform_buffer;
    Rendering::UniformBuffer light_buffer;
    Rendering::UniformBuffer material_buffer;

    // Bind blocks to the buffers
    transform_buffer.setBlock(transform);
    light_buffer.setBlock(point_light);
    material_buffer.setBlock(material);

    // Wrap it all up into an Effect
    GLuint texunit = GL_TEXTURE0, bindpoint = 0;
    std::shared_ptr<Rendering::PhongShading>phong_shading(
            new Rendering::PhongShading(
                texunit, bindpoint, 
                phong_program,
                stonebrick, stonebrickn,
                linear_blend, nearest_sample,
                transform_buffer, light_buffer, material_buffer
                )
            );

    // Create a new RenderNode
    systems.render->addNode(0, cube, {{phong_shading}}, {{transform}, {point_light}, {material}});

    // Add rigid bodies to the physics system
    cout << "Creating rigid bodies" << endl;

    float sixth = 1.0f/6.0f;

    State start;
    start.orientation = Quaternion( 1.0, Constants::ORIGIN );
    start.position = Vector(-1.0f, 1.0f, -1.5f);
    start.momentum = Constants::ORIGIN;
    start.angular_momentum = Constants::ORIGIN;
    start.mass = 1.0f;
    start.inverse_mass = 1.0f;
    start.inertia = glm::mat3(sixth, 0.0f, 0.0f, 0.0f, sixth, 0.0f, 0.0f, 0.0f, sixth);
    start.inverse_inertia = glm::inverse(start.inertia);
    systems.physics->addNode(1, start);

    State cube2 = start;
    cube2.position.x = 1.0f;
    cube2.angular_momentum = Vector(0.0f, 0.0025f, 0.0f);
    systems.physics->addNode(2, cube2);

    State cube3 = start;
    cube3.position.y = -1.0f;
    cube3.angular_momentum = Vector(0.0f, 0.0f, 0.0025f);
    systems.physics->addNode(3, cube3);

    State cube4 = cube2;
    cube4.position.y = -1.0f;
    cube4.angular_momentum = Vector(0.0025f, 0.0f, 0.0f);
    systems.physics->addNode(4, cube4);

    /* GO */
    cout << "Starting main loop" << endl;
    systems.dispatch->run(systems);

    cout << "Stopped." << endl;
    return 0;
}

